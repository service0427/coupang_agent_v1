/**
 * ÎèÖÎ¶Ω Ìä∏ÎûòÌîΩ ÏµúÏ†ÅÌôî ÌÖåÏä§Ìä∏ ÎèÑÍµ¨
 * - Ïã§ÏÑúÎπÑÏä§ ÏòÅÌñ• ÏóÜÎäî ÎèÖÎ¶Ω ÌôòÍ≤Ω
 * - ÏïàÏ†ÑÌïú Keep-Alive ÏµúÏ†ÅÌôî Í≤ÄÏ¶ù
 * - coupang.com Ìä∏ÎûòÌîΩ Ï∏°Ï†ï
 */

const { chromium } = require('playwright');
const path = require('path');

// Í≥†Ï†ï ÏÑ§Ï†ï
const PROFILE_PATH = 'd:\\dev\\git\\dev_coupang_chrome\\browser-data\\chrome';
const TEST_URL = 'https://www.coupang.com';

/**
 * Í∞ÑÏÜåÌôîÎêú ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®ÎãàÌÑ∞
 */
class SimpleNetworkMonitor {
  constructor() {
    this.requests = [];
    this.cacheHits = 0;
    this.connectionReuses = 0;
    this.startTime = Date.now();
  }

  async start(page, optimizationMode = 'none') {
    console.log(`üì° ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (${optimizationMode} Î™®Îìú)`);
    
    try {
      const client = await page.context().newCDPSession(page);
      await client.send('Network.enable');

      // ÏµúÏ†ÅÌôî Î™®ÎìúÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö©
      if (optimizationMode !== 'none') {
        await this.applyOptimizations(client, page, optimizationMode);
      }

      // ÏùëÎãµ ÏàòÏßë
      client.on('Network.responseReceived', (params) => {
        const { response } = params;
        
        const fromCache = response.fromMemoryCache || response.fromDiskCache || 
                         response.fromServiceWorker || response.status === 304;
        
        if (fromCache) {
          this.cacheHits++;
        }

        this.requests.push({
          url: response.url,
          status: response.status,
          size: response.encodedDataLength || 0,
          fromCache,
          timestamp: Date.now()
        });
      });

      // Î°úÎî© ÏôÑÎ£å Ï≤òÎ¶¨
      client.on('Network.loadingFinished', (params) => {
        // Ïó∞Í≤∞ Ïû¨ÏÇ¨Ïö© Í∞êÏßÄ (Í∞ÑÏ†ëÏ†Å)
        const recentRequests = this.requests.filter(r => 
          Date.now() - r.timestamp < 1000 && !r.fromCache
        );
        if (recentRequests.length > 3) {
          this.connectionReuses++;
        }
      });

    } catch (error) {
      console.log('‚ö†Ô∏è CDP ÏÑ§Ï†ï Ïã§Ìå®, Í∏∞Î≥∏ Î™®ÎãàÌÑ∞ÎßÅ ÏÇ¨Ïö©:', error.message);
      
      // Ìè¥Î∞±: Í∏∞Î≥∏ response Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö©
      page.on('response', (response) => {
        const fromCache = response.status() === 304 || false;
        
        if (fromCache) {
          this.cacheHits++;
        }

        this.requests.push({
          url: response.url(),
          status: response.status(),
          size: 0, // content-lengthÏóêÏÑú Ï∂îÏ†ï Í∞ÄÎä•ÌïòÏßÄÎßå ÏÉùÎûµ
          fromCache,
          timestamp: Date.now()
        });
      });
    }
  }

  /**
   * ÏµúÏ†ÅÌôî Î™®ÎìúÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö©
   */
  async applyOptimizations(client, page, mode) {
    console.log(`üöÄ ${mode} ÏµúÏ†ÅÌôî Ï†ÅÏö© Ï§ë...`);

    if (mode === 'safe' || mode === 'advanced') {
      // DNS ÌîÑÎ¶¨ÌéòÏπò (Î™®Îì† Î™®ÎìúÏóêÏÑú ÏïàÏ†Ñ)
      await page.evaluateOnNewDocument(() => {
        const prefetchDomains = [
          'www.coupang.com',
          'image7.coupangcdn.com',
          'static.coupangcdn.com'
        ];
        
        const head = document.head || document.getElementsByTagName('head')[0];
        
        prefetchDomains.forEach(domain => {
          const dnsLink = document.createElement('link');
          dnsLink.rel = 'dns-prefetch';
          dnsLink.href = `//${domain}`;
          head.appendChild(dnsLink);
          
          const preconnectLink = document.createElement('link');
          preconnectLink.rel = 'preconnect';
          preconnectLink.href = `https://${domain}`;
          head.appendChild(preconnectLink);
        });
        
        console.log('[ÏµúÏ†ÅÌôî] DNS ÌîÑÎ¶¨ÌéòÏπò ÏÑ§Ï†ï ÏôÑÎ£å');
      });
    }

    if (mode === 'advanced') {
      // ÏïàÏ†ÑÌïú Keep-Alive + Ïö∞ÏÑ†ÏàúÏúÑ Ï†úÏñ¥
      await client.send('Network.setRequestInterception', {
        patterns: [{ urlPattern: '*', requestStage: 'Request' }]
      });

      client.on('Network.requestPaused', async (params) => {
        const { requestId, request } = params;
        
        try {
          const headers = { ...request.headers };
          const url = request.url;
          
          // Ï†ïÏ†Å Î¶¨ÏÜåÏä§Îßå Keep-Alive (ÏïàÏ†Ñ)
          if (url.includes('.css') || url.includes('.js') || url.includes('.woff')) {
            headers['Connection'] = 'keep-alive';
            headers['Priority'] = 'u=1, i'; // Ï§ëÍ∞Ñ Ïö∞ÏÑ†ÏàúÏúÑ
            console.log('[ÏµúÏ†ÅÌôî] Keep-Alive Ï†ÅÏö©:', url.substring(0, 50) + '...');
          }
          // API/HTMLÏùÄ Í∏∞Î≥∏ Ïó∞Í≤∞ (ÏùµÎ™ÖÏÑ± Ïú†ÏßÄ)
          else if (url.includes('/api/') || url.includes('/search/')) {
            headers['Priority'] = 'u=0, i'; // ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ
          }
          // Ïù¥ÎØ∏ÏßÄÎäî ÎÇÆÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ
          else if (url.includes('image') || url.includes('thumbnail')) {
            headers['Priority'] = 'u=5, i';
          }
          
          await client.send('Network.continueRequestPaused', {
            requestId,
            headers
          });
          
        } catch (error) {
          await client.send('Network.continueRequestPaused', { requestId });
        }
      });
    }
  }

  /**
   * ÌÜµÍ≥Ñ Î∞òÌôò
   */
  getStats() {
    const duration = (Date.now() - this.startTime) / 1000;
    const totalSize = this.requests.reduce((sum, req) => sum + (req.size || 0), 0);
    const networkSize = this.requests
      .filter(req => !req.fromCache)
      .reduce((sum, req) => sum + (req.size || 0), 0);

    return {
      duration: duration.toFixed(2),
      totalRequests: this.requests.length,
      cacheHits: this.cacheHits,
      cacheHitRate: this.requests.length > 0 
        ? (this.cacheHits / this.requests.length * 100).toFixed(1)
        : 0,
      totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
      networkSizeMB: (networkSize / (1024 * 1024)).toFixed(2),
      connectionReuses: this.connectionReuses,
      topDomains: this.getTopDomains(5)
    };
  }

  getTopDomains(limit = 5) {
    const domainStats = {};
    
    this.requests.forEach(req => {
      try {
        const domain = new URL(req.url).hostname;
        if (!domainStats[domain]) {
          domainStats[domain] = { count: 0, size: 0 };
        }
        domainStats[domain].count++;
        domainStats[domain].size += req.size || 0;
      } catch (e) {
        // URL ÌååÏã± Ïã§Ìå® Î¨¥Ïãú
      }
    });

    return Object.entries(domainStats)
      .sort((a, b) => b[1].size - a[1].size)
      .slice(0, limit)
      .map(([domain, stats]) => ({
        domain,
        count: stats.count,
        sizeMB: (stats.size / (1024 * 1024)).toFixed(2)
      }));
  }
}

/**
 * ÌÖåÏä§Ìä∏ Ïã§Ìñâ
 */
async function runOptimizationTest(mode = 'none') {
  console.log(`\nüß™ Ìä∏ÎûòÌîΩ ÏµúÏ†ÅÌôî ÌÖåÏä§Ìä∏ ÏãúÏûë (${mode} Î™®Îìú)`);
  console.log(`üìÅ ÌîÑÎ°úÌïÑ: ${PROFILE_PATH}`);
  console.log(`üåê URL: ${TEST_URL}\n`);

  const monitor = new SimpleNetworkMonitor();
  let context = null;
  let page = null;

  try {
    // Persistent ContextÎ°ú Î∏åÎùºÏö∞Ï†Ä ÏãúÏûë
    context = await chromium.launchPersistentContext(PROFILE_PATH, {
      headless: false,
      channel: 'chrome',
      viewport: { width: 1200, height: 800 },
      args: [
        '--disable-blink-features=AutomationControlled',
        '--disable-web-security',
        '--disable-features=VizDisplayCompositor'
      ]
    });

    // Í∏∞Ï°¥ ÌéòÏù¥ÏßÄ ÏÇ¨Ïö© ÎòêÎäî ÏÉà ÌéòÏù¥ÏßÄ ÏÉùÏÑ±
    const pages = context.pages();
    page = pages.length > 0 ? pages[0] : await context.newPage();

    // ÏûêÎèôÌôî ÌùîÏ†Å Ï†úÍ±∞
    await page.addInitScript(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      delete window.chrome.runtime;
    });

    // ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    await monitor.start(page, mode);

    console.log('üöÄ Ïø†Ìå° ÌéòÏù¥ÏßÄ Î°úÎî© Ï§ë...');
    
    // ÌéòÏù¥ÏßÄ Î°úÎìú
    await page.goto(TEST_URL, { 
      waitUntil: 'networkidle',
      timeout: 30000 
    });

    console.log('‚è≥ Ï∂îÍ∞Ä Î¶¨ÏÜåÏä§ Î°úÎî© ÎåÄÍ∏∞ (5Ï¥à)...');
    await page.waitForTimeout(5000);

    // ÌÜµÍ≥Ñ Ï∂úÎ†•
    const stats = monitor.getStats();
    
    console.log('\nüìä Ìä∏ÎûòÌîΩ ÌÜµÍ≥Ñ:');
    console.log(`   Î°úÎî© ÏãúÍ∞Ñ: ${stats.duration}Ï¥à`);
    console.log(`   Ï¥ù ÏöîÏ≤≠ Ïàò: ${stats.totalRequests}Í∞ú`);
    console.log(`   Ï∫êÏãú ÌûàÌä∏: ${stats.cacheHits}Í∞ú (${stats.cacheHitRate}%)`);
    console.log(`   Ï¥ù Ìä∏ÎûòÌîΩ: ${stats.totalSizeMB}MB`);
    console.log(`   ÎÑ§Ìä∏ÏõåÌÅ¨: ${stats.networkSizeMB}MB`);
    console.log(`   Ïó∞Í≤∞ Ïû¨ÏÇ¨Ïö©: ${stats.connectionReuses}Ìöå`);
    
    console.log('\nüèÜ ÏÉÅÏúÑ ÎèÑÎ©îÏù∏:');
    stats.topDomains.forEach((domain, i) => {
      console.log(`   ${i+1}. ${domain.domain}: ${domain.count}Í∞ú, ${domain.sizeMB}MB`);
    });

    return stats;

  } catch (error) {
    console.error('‚ùå ÌÖåÏä§Ìä∏ Ïã§Ìå®:', error.message);
    return null;
  } finally {
    try {
      if (page) await page.close();
      if (context) await context.close();
      console.log('‚úÖ Î∏åÎùºÏö∞Ï†Ä Ï¢ÖÎ£å ÏôÑÎ£å\n');
    } catch (e) {
      console.log('‚ö†Ô∏è Î∏åÎùºÏö∞Ï†Ä Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', e.message);
    }
  }
}

/**
 * ÎπÑÍµê ÌÖåÏä§Ìä∏ Ïã§Ìñâ
 */
async function runComparisonTest() {
  console.log('üéØ Ìä∏ÎûòÌîΩ ÏµúÏ†ÅÌôî ÎπÑÍµê ÌÖåÏä§Ìä∏ ÏãúÏûë\n');
  console.log('='.repeat(60));

  const modes = [
    { name: 'none', desc: 'ÏµúÏ†ÅÌôî ÏóÜÏùå (Î≤†Ïù¥Ïä§ÎùºÏù∏)' },
    { name: 'safe', desc: 'DNS ÌîÑÎ¶¨ÌéòÏπòÎßå (ÏïàÏ†Ñ)' },
    { name: 'advanced', desc: 'ÏÑ†ÌÉùÏ†Å Keep-Alive + Ïö∞ÏÑ†ÏàúÏúÑ' }
  ];

  const results = {};

  for (const mode of modes) {
    console.log(`\nüìã Î™®Îìú: ${mode.desc}`);
    console.log('-'.repeat(40));
    
    const stats = await runOptimizationTest(mode.name);
    if (stats) {
      results[mode.name] = stats;
    }

    // ÌÖåÏä§Ìä∏ Í∞Ñ Í∞ÑÍ≤©
    if (mode !== modes[modes.length - 1]) {
      console.log('‚è≥ Îã§Ïùå ÌÖåÏä§Ìä∏ÍπåÏßÄ 3Ï¥à ÎåÄÍ∏∞...');
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
  }

  // ÏµúÏ¢Ö ÎπÑÍµê Î¶¨Ìè¨Ìä∏
  console.log('\nüìä ÏµúÏ¢Ö ÎπÑÍµê Î¶¨Ìè¨Ìä∏');
  console.log('='.repeat(60));
  
  Object.entries(results).forEach(([mode, stats]) => {
    const modeDesc = modes.find(m => m.name === mode)?.desc || mode;
    console.log(`\nüîπ ${modeDesc}:`);
    console.log(`   Ï¥ù Ìä∏ÎûòÌîΩ: ${stats.totalSizeMB}MB`);
    console.log(`   ÎÑ§Ìä∏ÏõåÌÅ¨: ${stats.networkSizeMB}MB`);
    console.log(`   Ï∫êÏãúÏú®: ${stats.cacheHitRate}%`);
    console.log(`   Î°úÎî©ÏãúÍ∞Ñ: ${stats.duration}Ï¥à`);
  });

  // Í∞úÏÑ† Ìö®Í≥º Í≥ÑÏÇ∞
  if (results.none && results.advanced) {
    const baseline = parseFloat(results.none.networkSizeMB);
    const optimized = parseFloat(results.advanced.networkSizeMB);
    const improvement = baseline > 0 ? ((baseline - optimized) / baseline * 100).toFixed(1) : 0;
    
    console.log(`\nüí° ÏµúÏ†ÅÌôî Ìö®Í≥º: ${improvement}% ÎÑ§Ìä∏ÏõåÌÅ¨ Ìä∏ÎûòÌîΩ Ï†àÍ∞ê`);
    console.log(`   (${baseline}MB ‚Üí ${optimized}MB)`);
  }
}

// Ïã§Ìñâ
if (require.main === module) {
  const mode = process.argv[2] || 'comparison';
  
  if (mode === 'comparison') {
    runComparisonTest();
  } else {
    runOptimizationTest(mode);
  }
}

module.exports = { runOptimizationTest, runComparisonTest };