/**
 * 통합 네트워크 트래픽 관리자 V3
 * - 키워드 ID 정보가 모든 로그에 표시
 * - CLI 플래그 기반 모드 전환 
 * - 최적화 컨텍스트 통합
 * - 캐시 통계 정확성 보장
 * - 멀티모드 개별 키워드 구분
 */

const NetworkMonitor = require('../network/monitor');
const NetworkAnalyzer = require('../network/analyzer');

class IntegratedTrafficManager {
  constructor(options = {}) {
    // 필수 식별 정보
    this.keywordId = options.keywordId || null;
    this.agent = options.agent || null;
    this.keyword = options.keyword || '';
    
    // 모드 설정
    this.verboseMode = options.verbose || options.trafficDetail || false;
    this.saveReports = options.saveReports || false;
    
    // 최적화 컨텍스트
    this.optimizationContext = options.optimizationContext || null;
    
    // 내부 컴포넌트
    this.monitor = new NetworkMonitor();
    this.analyzer = new NetworkAnalyzer();
    this.isActive = false;
    
    // 로그 식별자
    this.logPrefix = this._createLogPrefix();
  }
  
  /**
   * 로그 식별자 생성
   */
  _createLogPrefix() {
    if (this.agent && this.keywordId) {
      return `[${this.agent}:${this.keywordId}]`;
    } else if (this.keywordId) {
      return `[ID:${this.keywordId}]`;
    } else if (this.agent) {
      return `[${this.agent}]`;
    }
    return '[Traffic]';
  }
  
  /**
   * 키워드 ID 포함 로그 출력
   */
  logWithId(message, level = 'info') {
    console.log(`${this.logPrefix} ${message}`);
  }
  
  /**
   * 트래픽 모니터링 시작
   */
  async start(page) {
    if (this.isActive) {
      this.logWithId('⚠️ 이미 모니터링이 활성화되어 있습니다.');
      return;
    }
    
    this.isActive = true;
    await this.monitor.start(page);
    
    if (this.verboseMode) {
      this.logWithId('📡 네트워크 모니터링 시작 (상세 모드)');
    } else {
      this.logWithId('📡 네트워크 모니터링 시작 (간단 모드)');
    }
  }
  
  /**
   * 트래픽 모니터링 중지 및 분석
   */
  async stop() {
    if (!this.isActive) {
      this.logWithId('⚠️ 모니터링이 활성화되어 있지 않습니다.');
      return null;
    }
    
    this.isActive = false;
    this.logWithId('📡 네트워크 트래픽 모니터링 중지');
    await this.monitor.stop();
    
    // 데이터 수집 및 분석
    const networkData = this.monitor.getData();
    const analysisResult = this.analyzer.analyze(networkData, this.optimizationContext);
    
    // 데이터 검증
    this._validateData(networkData, analysisResult);
    
    // 결과 출력
    this._outputResults(analysisResult);
    
    // 리포트 저장
    if (this.saveReports && this.keywordId && this.agent) {
      await this._saveReports(analysisResult);
    }
    
    return analysisResult;
  }
  
  /**
   * 데이터 일관성 검증
   */
  _validateData(networkData, analysisResult) {
    const monitorCached = networkData.cacheStats?.fromCache || 0;
    const analyzerCached = analysisResult.requests?.filter(req => req.fromCache).length || 0;
    
    if (Math.abs(monitorCached - analyzerCached) > 0) {
      this.logWithId(`⚠️ 캐시 데이터 불일치: Monitor=${monitorCached}, Analyzer=${analyzerCached}`);
    }
    
    if (this.verboseMode) {
      this.logWithId(`🔍 데이터 검증: 요청=${networkData.totalRequests}개, 캐시=${monitorCached}개`);
    }
  }
  
  /**
   * 결과 출력 (모드별)
   */
  _outputResults(analysisResult) {
    if (this.verboseMode) {
      this._printDetailedAnalysis(analysisResult);
    } else {
      this._printSimpleSummary(analysisResult);
    }
  }
  
  /**
   * 간단 요약 출력
   */
  _printSimpleSummary(analysisResult) {
    const { summary, cacheStats, recommendations } = analysisResult;
    
    this.logWithId(`📊 트래픽 요약: ${summary.totalRequests}개 요청, ${summary.totalSizeInMB}MB`);
    
    // 캐시 효율성
    if (cacheStats && cacheStats.fromCache > 0) {
      const cachedRequests = analysisResult.requests.filter(req => req.fromCache);
      const cachedSize = cachedRequests.reduce((sum, req) => sum + (req.size || 0), 0);
      const cacheSavingsMB = (cachedSize / 1024 / 1024).toFixed(2);
      
      this.logWithId(`💾 캐시 절감: ${cacheStats.fromCache}개 (${cacheStats.cacheHitRate}%) → ${cacheSavingsMB}MB 절약`);
    } else {
      this.logWithId(`💾 캐시 사용률: 0% (캐시 활용 없음)`);
    }
    
    // 주요 권장사항
    const highPriorityRecs = recommendations.filter(rec => rec.priority === 'HIGH');
    if (highPriorityRecs.length > 0) {
      this.logWithId(`💡 최적화 기회: ${highPriorityRecs.length}개`);
      highPriorityRecs.slice(0, 2).forEach(rec => {
        if (rec.savingPotential) {
          this.logWithId(`   - ${rec.type}: ${rec.savingPotential} 절약 가능`);
        }
      });
    }
    
    // 효율성 점수
    const efficiencyScore = this._calculateEfficiencyScore(analysisResult);
    this.logWithId(`⚡ 효율성 점수: ${efficiencyScore}/100`);
  }
  
  /**
   * 상세 분석 출력
   */
  _printDetailedAnalysis(analysisResult) {
    const { summary, domains, resourceTypes, protocols, largeResources, recommendations, cacheStats } = analysisResult;
    
    console.log('\n' + '='.repeat(80));
    console.log(`${this.logPrefix} 📊 네트워크 트래픽 분석 결과 (상세)`);
    console.log('='.repeat(80));
    
    // 요약 정보
    console.log('\n📈 요약:');
    console.log(`   총 요청 수: ${summary.totalRequests}개`);
    console.log(`   총 데이터 크기: ${summary.totalSizeInMB} MB`);
    console.log(`   평균 요청 크기: ${(summary.avgRequestSize / 1024).toFixed(2)} KB`);
    console.log(`   초당 요청 수: ${summary.requestsPerSecond}`);
    console.log(`   분석 시간: ${summary.duration}초`);
    
    // 상위 도메인
    console.log('\n🌐 상위 도메인 (데이터 사용량 기준):');
    domains.slice(0, 10).forEach((domain, index) => {
      console.log(`   ${index + 1}. ${domain.domain}`);
      console.log(`      요청: ${domain.count}개, 크기: ${(domain.size / 1024 / 1024).toFixed(2)} MB (${domain.percentage}%)`);
      
      const topTypes = domain.types.sort((a, b) => b.size - a.size).slice(0, 3);
      topTypes.forEach(type => {
        console.log(`        - ${type.type}: ${type.count}개, ${(type.size / 1024 / 1024).toFixed(2)} MB`);
      });
    });
    
    // 리소스 타입별 분포
    console.log('\n📁 리소스 타입별 분포:');
    resourceTypes.forEach(type => {
      const sizeInMB = (type.size / 1024 / 1024).toFixed(2);
      console.log(`   ${type.type}: ${type.count}개, ${sizeInMB} MB (${type.percentage}%)`);
    });
    
    // 프로토콜 사용 현황
    console.log('\n🔐 프로토콜 사용 현황:');
    protocols.forEach(proto => {
      console.log(`   ${proto.protocol}: ${proto.count}개 (${proto.percentage}%)`);
    });
    
    // 캐시 통계
    if (cacheStats) {
      console.log('\n💾 캐시 사용 현황:');
      console.log(`   전체 요청: ${cacheStats.total}개`);
      console.log(`   캐시 히트: ${cacheStats.fromCache}개 (${cacheStats.cacheHitRate}%)`);
      console.log(`   네트워크: ${cacheStats.fromNetwork}개`);
      
      if (cacheStats.fromCache > 0) {
        const cachedRequests = analysisResult.requests.filter(req => req.fromCache);
        const cachedSize = cachedRequests.reduce((sum, req) => sum + (req.size || 0), 0);
        console.log(`   캐시된 데이터: ${(cachedSize / 1024 / 1024).toFixed(2)} MB`);
        
        if (cacheStats.byType && cacheStats.byType.length > 0) {
          console.log('\n   리소스 타입별 캐시 히트율:');
          cacheStats.byType
            .sort((a, b) => b.total - a.total)
            .forEach(type => {
              console.log(`   - ${type.type}: ${type.cached}/${type.total} (${type.hitRate}%)`);
            });
        }
      }
    }
    
    // 대용량 리소스
    if (largeResources.length > 0) {
      console.log('\n⚠️  대용량 리소스 (1MB 이상):');
      largeResources.slice(0, 3).forEach((resource, index) => {
        console.log(`   ${index + 1}. ${resource.domain} - ${resource.type}`);
        console.log(`      크기: ${resource.sizeInMB} MB`);
      });
    }
    
    // 권장사항
    if (recommendations.length > 0) {
      console.log('\n💡 트래픽 감소 권장사항:');
      recommendations.forEach((rec, index) => {
        console.log(`\n   ${index + 1}. [${rec.priority}] ${rec.type}`);
        console.log(`      ${rec.message}`);
        if (rec.savingPotential) {
          console.log(`      예상 절감량: ${rec.savingPotential}`);
        }
      });
    }
    
    console.log('\n' + '='.repeat(80));
  }
  
  /**
   * 효율성 점수 계산 (0-100)
   */
  _calculateEfficiencyScore(analysisResult) {
    const { summary, cacheStats, recommendations } = analysisResult;
    let score = 70; // 기본 점수
    
    // 캐시 효율성 점수 (30점)
    if (cacheStats) {
      const cacheHitRate = parseFloat(cacheStats.cacheHitRate || 0);
      score += Math.min(30, cacheHitRate * 0.3);
    }
    
    // 트래픽 크기 점수
    const sizeInMB = parseFloat(summary.totalSizeInMB);
    if (sizeInMB <= 0.5) score += 20;      // 0.5MB 이하: 만점
    else if (sizeInMB <= 1.0) score += 15; // 1MB 이하: 우수
    else if (sizeInMB <= 2.0) score += 10; // 2MB 이하: 양호
    else if (sizeInMB <= 5.0) score += 5;  // 5MB 이하: 보통
    else score -= 10; // 5MB 초과: 감점
    
    // 권장사항 페널티
    const highPriorityIssues = recommendations.filter(rec => rec.priority === 'HIGH').length;
    score -= highPriorityIssues * 5;
    
    return Math.max(0, Math.min(100, Math.round(score)));
  }
  
  /**
   * 리포트 저장
   */
  async _saveReports(analysisResult) {
    try {
      this.logWithId('📄 트래픽 리포트 저장 중...');
      
      await this.analyzer.saveReport(this.keywordId, this.agent);
      
      if (analysisResult.cacheStats && analysisResult.cacheStats.fromCache > 0) {
        await this.analyzer.saveCacheReport(this.keywordId, this.agent);
      }
      
      this.logWithId('📄 트래픽 리포트 저장 완료');
    } catch (error) {
      this.logWithId(`⚠️ 리포트 저장 실패: ${error.message}`);
    }
  }
  
  /**
   * 런타임 모드 전환
   */
  setVerboseMode(enabled) {
    this.verboseMode = enabled;
    this.logWithId(`🔧 모드 변경: ${enabled ? '상세' : '간단'} 모드`);
  }
  
  /**
   * 현재 캐시 통계 조회
   */
  getCurrentCacheStats() {
    if (!this.isActive) {
      return { message: '모니터링이 활성화되지 않았습니다.' };
    }
    
    const data = this.monitor.getData();
    const { cacheStats } = data;
    
    if (!cacheStats || cacheStats.total === 0) {
      return { message: '아직 캐시 데이터가 없습니다.' };
    }
    
    const cachedRequests = data.requests.filter(req => req.fromCache);
    const cacheSavingsMB = cachedRequests.reduce((sum, req) => sum + (req.size || 0), 0) / 1024 / 1024;
    
    return {
      total: cacheStats.total,
      cached: cacheStats.fromCache,
      hitRate: cacheStats.cacheHitRate,
      savingsMB: cacheSavingsMB.toFixed(2),
      memoryCache: cacheStats.fromMemoryCache,
      diskCache: cacheStats.fromDiskCache
    };
  }
  
  /**
   * 리소스 정리
   */
  async cleanup() {
    if (this.isActive) {
      this.logWithId('🧹 트래픽 매니저 정리 중...');
      await this.stop();
    }
    this.monitor.reset();
    this.logWithId('✅ 트래픽 매니저 정리 완료');
  }
}

module.exports = IntegratedTrafficManager;