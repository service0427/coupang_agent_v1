/**
 * Ìñ•ÏÉÅÎêú Ïï°ÏÖò Î°úÍ∑∏ Í∏∞Î°ù Î™®Îìà
 * - ÏÉÅÌÉú Í∏∞Î∞ò Ïï°ÏÖò Ï∂îÏ†Å
 * - ÏÉÅÌÉú Ï†ÑÌôò Í≤ÄÏ¶ù
 * - ÏûêÎèô ÌÉÄÏù¥Î∞ç Ï∏°Ï†ï
 */

const dbServiceV2 = require('./db-service-v2');
const { 
  ActionStatus, 
  ActionType, 
  ProcessStep, 
  ErrorLevel,
  isValidTransition,
  isSuccessStatus,
  isErrorStatus 
} = require('../constants/action-status');

class ActionLoggerV2 {
  constructor(executionId, sessionId) {
    this.executionId = executionId;
    this.sessionId = sessionId;
    this.actionSequence = 0;
    this.activeActions = new Map(); // ÏßÑÌñâ Ï§ëÏù∏ Ïï°ÏÖòÎì§
    this.actionHistory = [];
    this.currentActionId = null; // ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ Ïï°ÏÖò ID
  }

  /**
   * ÌòÑÏû¨ Ïï°ÏÖòÏùò Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ID Î∞òÌôò
   */
  getCurrentActionDbId() {
    if (!this.currentActionId) return null;
    const action = this.activeActions.get(this.currentActionId);
    return action?.dbId || null;
  }

  /**
   * Ïï°ÏÖò ÏãúÏûë - ÏÉÅÌÉú Í∏∞Î∞ò
   */
  async startAction(actionType, actionTarget, options = {}) {
    this.actionSequence++;
    const actionId = `action_${this.executionId}_${this.actionSequence}`;
    const startTime = Date.now();
    
    const action = {
      id: actionId,
      sequence: this.actionSequence,
      type: actionType,
      target: actionTarget,
      status: ActionStatus.INIT,
      processStep: options.processStep || this.determineProcessStep(actionType),
      startTime,
      statusHistory: [{
        status: ActionStatus.INIT,
        timestamp: startTime,
        duration: 0
      }],
      detail: options.detail || {},
      metrics: {
        retryCount: 0,
        networkRequests: 0,
        domMutations: 0
      }
    };
    
    this.activeActions.set(actionId, action);
    this.currentActionId = actionId; // ÌòÑÏû¨ Ïï°ÏÖò IDÎ°ú ÏÑ§Ï†ï
    
    // DBÏóê Ï¥àÍ∏∞ ÏÉÅÌÉú Í∏∞Î°ù
    try {
      const dbActionId = await dbServiceV2.logActionV2(
        this.executionId,
        this.sessionId,
        {
          actionSeq: this.actionSequence,
          actionType,
          actionTarget,
          actionDetail: {
            ...options.detail,
            status: ActionStatus.INIT,
            processStep: action.processStep
          },
          processStep: action.processStep
        }
      );
      
      action.dbId = dbActionId;
      
      // ÏûêÎèôÏúºÎ°ú PENDING ÏÉÅÌÉúÎ°ú Ï†ÑÌôò
      await this.updateActionStatus(actionId, ActionStatus.PENDING, {}, true);
      
      console.log(`\nüéØ [${this.actionSequence}] ${actionType}: ${actionTarget}`);
      console.log(`   ‚îî‚îÄ ÏÉÅÌÉú: ${ActionStatus.INIT} ‚Üí ${ActionStatus.PENDING}`);
      
    } catch (error) {
      console.error('Ïï°ÏÖò ÏãúÏûë Î°úÍ∑∏ Ïã§Ìå®:', error);
      action.error = error;
    }
    
    return actionId;
  }

  /**
   * Ïï°ÏÖò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
   */
  async updateActionStatus(actionId, newStatus, data = {}, forceTransition = false) {
    const action = this.activeActions.get(actionId);
    if (!action) {
      console.error(`Ïï°ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${actionId}`);
      return false;
    }
    
    // undefined ÏÉÅÌÉú Ï≤¥ÌÅ¨
    if (!newStatus || newStatus === 'undefined') {
      console.warn(`‚ö†Ô∏è  ÏûòÎ™ªÎêú ÏÉÅÌÉú Í∞í: ${newStatus} (actionId: ${actionId})`);
      return false;
    }
    
    const currentStatus = action.status;
    const timestamp = Date.now();
    
    // ÏÉÅÌÉú Ï†ÑÌôò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (!forceTransition && !isValidTransition(currentStatus, newStatus)) {
      // Í∞úÎ∞ú Îã®Í≥ÑÏóêÏÑúÎäî Ïú†Ïó∞Ìïú Ï†ÑÌôò ÌóàÏö©, Î°úÍ∑∏ Î†àÎ≤®ÎèÑ ÎÇÆÏ∂§
      if (!this.isFlexibleTransition(currentStatus, newStatus)) {
        console.warn(`‚ö†Ô∏è  ÏûòÎ™ªÎêú ÏÉÅÌÉú Ï†ÑÌôò: ${currentStatus} ‚Üí ${newStatus}`);
        return false;
      }
      // Ïú†Ïó∞Ìïú Ï†ÑÌôòÏùò Í≤ΩÏö∞ ÎîîÎ≤ÑÍ∑∏ Î†àÎ≤®Î°úÎßå Ï∂úÎ†•
      // console.debug(`üîÄ Ïú†Ïó∞Ìïú ÏÉÅÌÉú Ï†ÑÌôò: ${currentStatus} ‚Üí ${newStatus}`);
    }
    
    // Ïù¥Ï†Ñ ÏÉÅÌÉúÏùò ÏßÄÏÜç ÏãúÍ∞Ñ Í≥ÑÏÇ∞
    const lastStatusEntry = action.statusHistory[action.statusHistory.length - 1];
    lastStatusEntry.duration = timestamp - lastStatusEntry.timestamp;
    
    // ÏÉà ÏÉÅÌÉú Í∏∞Î°ù
    action.status = newStatus;
    action.statusHistory.push({
      status: newStatus,
      timestamp,
      duration: 0,
      data
    });
    
    // ÏÉÅÌÉúÎ≥Ñ Ï∂îÍ∞Ä Ï≤òÎ¶¨
    await this.handleStatusChange(action, newStatus, data);
    
    // Î°úÍ∑∏ Ï∂úÎ†•
    const statusIcon = this.getStatusIcon(newStatus);
    console.log(`   ${statusIcon} ÏÉÅÌÉú: ${currentStatus} ‚Üí ${newStatus} (${lastStatusEntry.duration}ms)`);
    
    if (data.message) {
      console.log(`   ‚îî‚îÄ ${data.message}`);
    }
    
    return true;
  }

  /**
   * ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï≤òÎ¶¨
   */
  async handleStatusChange(action, newStatus, data) {
    switch (newStatus) {
      case ActionStatus.STARTED:
        action.actualStartTime = Date.now();
        break;
        
      case ActionStatus.DOM_READY:
        action.metrics.domReadyTime = Date.now() - action.actualStartTime;
        break;
        
      case ActionStatus.LOADED:
        action.metrics.loadCompleteTime = Date.now() - action.actualStartTime;
        break;
        
      case ActionStatus.ELEMENT_FOUND:
        action.metrics.elementFoundTime = Date.now() - action.actualStartTime;
        break;
        
      case ActionStatus.SUCCESS:
      case ActionStatus.PARTIAL_SUCCESS:
        await this.completeAction(action.id, {
          success: true,
          partialSuccess: newStatus === ActionStatus.PARTIAL_SUCCESS,
          ...data
        });
        break;
        
      default:
        if (isErrorStatus(newStatus)) {
          await this.completeAction(action.id, {
            success: false,
            errorType: newStatus,
            errorMessage: data.message || `Ïï°ÏÖò Ïã§Ìå®: ${newStatus}`,
            ...data
          });
        }
    }
  }

  /**
   * Ïï°ÏÖò ÏôÑÎ£å
   */
  async completeAction(actionId, result) {
    const action = this.activeActions.get(actionId);
    if (!action) return;
    
    const endTime = Date.now();
    const totalDuration = endTime - action.startTime;
    
    // ÏµúÏ¢Ö ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    if (!isSuccessStatus(action.status) && !isErrorStatus(action.status)) {
      // Î™ÖÏãúÏ†ÅÏù∏ ÏôÑÎ£å ÏÉÅÌÉúÍ∞Ä ÏóÜÏúºÎ©¥ Í≤∞Í≥ºÏóê Îî∞Îùº ÏÑ§Ï†ï
      const finalStatus = result.success ? ActionStatus.SUCCESS : ActionStatus.ERROR_UNKNOWN;
      await this.updateActionStatus(actionId, finalStatus, result);
    }
    
    // Ïï°ÏÖò ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
    this.actionHistory.push({
      ...action,
      endTime,
      totalDuration,
      result
    });
    
    // ÌôúÏÑ± Ïï°ÏÖòÏóêÏÑú Ï†úÍ±∞
    this.activeActions.delete(actionId);
    
    // ÌòÑÏû¨ Ïï°ÏÖòÏù¥ÏóàÎã§Î©¥ Î¶¨ÏÖã
    if (this.currentActionId === actionId) {
      this.currentActionId = null;
    }
    
    // DB ÏóÖÎç∞Ïù¥Ìä∏ (TODO: db-service-v2Ïóê updateAction Î©îÏÑúÎìú Ï∂îÍ∞Ä ÌïÑÏöî)
    try {
      // ÏÉÅÌÉú ÏöîÏïΩ ÏÉùÏÑ±
      const statusSummary = this.generateStatusSummary(action);
      
      const updateData = {
        success: result.success,
        errorType: result.errorType,
        errorMessage: result.errorMessage,
        duration_ms: totalDuration,
        dom_ready_ms: action.metrics.domReadyTime,
        load_complete_ms: action.metrics.loadCompleteTime,
        current_url: result.currentUrl,
        page_title: result.pageTitle,
        element_visible: result.elementVisible,
        element_clickable: result.elementClickable,
        completed_at: new Date(endTime),
        action_detail: {
          ...action.detail,
          statusHistory: action.statusHistory,
          metrics: action.metrics,
          statusSummary
        }
      };
      
      // await dbServiceV2.updateActionV2(action.dbId, updateData);
      
    } catch (error) {
      console.error('Ïï°ÏÖò ÏôÑÎ£å ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
    }
    
    // ÏôÑÎ£å Î°úÍ∑∏
    const statusIcon = result.success ? '‚úÖ' : '‚ùå';
    console.log(`   ${statusIcon} Ïï°ÏÖò ÏôÑÎ£å (${totalDuration}ms)`);
    if (action.statusHistory.length > 2) {
      console.log(`   ‚îî‚îÄ ÏÉÅÌÉú Ï†ÑÌôò: ${this.generateStatusPath(action)}`);
    }
  }

  /**
   * ÏÉÅÌÉú ÏöîÏïΩ ÏÉùÏÑ±
   */
  generateStatusSummary(action) {
    const summary = {
      totalStates: action.statusHistory.length,
      timeInStates: {},
      criticalPath: []
    };
    
    // Í∞Å ÏÉÅÌÉúÎ≥Ñ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
    action.statusHistory.forEach(entry => {
      if (!summary.timeInStates[entry.status]) {
        summary.timeInStates[entry.status] = 0;
      }
      summary.timeInStates[entry.status] += entry.duration;
      
      // Ï£ºÏöî ÏÉÅÌÉúÎßå critical pathÏóê Ìè¨Ìï®
      if ([
        ActionStatus.STARTED,
        ActionStatus.DOM_READY,
        ActionStatus.LOADED,
        ActionStatus.ELEMENT_FOUND,
        ActionStatus.CLICKED,
        ActionStatus.SUCCESS,
        ActionStatus.PARTIAL_SUCCESS
      ].includes(entry.status) || isErrorStatus(entry.status)) {
        summary.criticalPath.push({
          status: entry.status,
          timestamp: entry.timestamp,
          duration: entry.duration
        });
      }
    });
    
    return summary;
  }

  /**
   * ÏÉÅÌÉú Í≤ΩÎ°ú ÏÉùÏÑ±
   */
  generateStatusPath(action) {
    return action.statusHistory
      .map(entry => entry.status)
      .join(' ‚Üí ');
  }

  /**
   * ÌîÑÎ°úÏÑ∏Ïä§ Îã®Í≥Ñ Í≤∞Ï†ï
   */
  determineProcessStep(actionType) {
    const stepMap = {
      [ActionType.NAVIGATE]: ProcessStep.NAVIGATION,
      [ActionType.SEARCH_INPUT]: ProcessStep.SEARCH,
      [ActionType.SEARCH_SUBMIT]: ProcessStep.SEARCH,
      [ActionType.PRODUCT_SEARCH]: ProcessStep.FIND_PRODUCT,
      [ActionType.PRODUCT_CLICK]: ProcessStep.CLICK_PRODUCT,
      [ActionType.CART_CLICK]: ProcessStep.ADD_CART,
      [ActionType.WAIT_NAVIGATION]: ProcessStep.WAIT,
      [ActionType.WAIT_SELECTOR]: ProcessStep.WAIT
    };
    
    return stepMap[actionType] || ProcessStep.INITIALIZATION;
  }

  /**
   * ÏÉÅÌÉú ÏïÑÏù¥ÏΩò Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getStatusIcon(status) {
    const iconMap = {
      [ActionStatus.INIT]: 'üîÑ',
      [ActionStatus.PENDING]: '‚è≥',
      [ActionStatus.STARTED]: '‚ñ∂Ô∏è',
      [ActionStatus.NAVIGATING]: 'üöÄ',
      [ActionStatus.DOM_READY]: 'üìÑ',
      [ActionStatus.LOADED]: '‚úì',
      [ActionStatus.ELEMENT_FOUND]: 'üéØ',
      [ActionStatus.CLICKING]: 'üëÜ',
      [ActionStatus.SUCCESS]: '‚úÖ',
      [ActionStatus.PARTIAL_SUCCESS]: '‚ö†Ô∏è',
      [ActionStatus.ERROR_TIMEOUT]: '‚è±Ô∏è',
      [ActionStatus.ERROR_BLOCKED]: 'üö´',
      [ActionStatus.ERROR_CRITICAL]: 'üí•'
    };
    
    return iconMap[status] || '‚Ä¢';
  }

  /**
   * ÌäπÌôîÎêú Ïï°ÏÖò Î©îÏÑúÎìúÎì§
   */
  async logNavigation(url, options = {}) {
    const actionId = await this.startAction(ActionType.NAVIGATE, url, {
      ...options,
      processStep: ProcessStep.NAVIGATION
    });
    
    // ÏûêÎèôÏúºÎ°ú STARTED ÏÉÅÌÉúÎ°ú
    await this.updateActionStatus(actionId, ActionStatus.STARTED, {}, true);
    await this.updateActionStatus(actionId, ActionStatus.NAVIGATING, {}, true);
    
    return actionId;
  }

  async logClick(selector, options = {}) {
    const actionId = await this.startAction(ActionType.CLICK, selector, options);
    await this.updateActionStatus(actionId, ActionStatus.STARTED, {}, true);
    await this.updateActionStatus(actionId, ActionStatus.ELEMENT_WAITING, {}, true);
    
    return actionId;
  }

  async logProductSearch(keyword, options = {}) {
    const actionId = await this.startAction(ActionType.PRODUCT_SEARCH, keyword, {
      ...options,
      processStep: ProcessStep.FIND_PRODUCT
    });
    
    await this.updateActionStatus(actionId, ActionStatus.STARTED, {}, true);
    
    return actionId;
  }

  /**
   * ÌéòÏù¥ÏßÄ Î°úÎìú ÏÉÅÌÉú Ï∂îÏ†Å
   */
  async trackPageLoad(actionId, page) {
    try {
      // DOM ÏÉÅÌò∏ÏûëÏö© Í∞ÄÎä•
      await page.waitForLoadState('domcontentloaded', { timeout: 5000 });
      await this.updateActionStatus(actionId, ActionStatus.DOM_READY);
      
      // ÌéòÏù¥ÏßÄ ÏôÑÏ†Ñ Î°úÎìú
      await page.waitForLoadState('load', { timeout: 10000 });
      await this.updateActionStatus(actionId, ActionStatus.LOADED);
      
      // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïú†Ìú¥ ÏÉÅÌÉú
      await page.waitForLoadState('networkidle', { timeout: 15000 });
      await this.updateActionStatus(actionId, ActionStatus.NETWORK_IDLE);
      
      return true;
    } catch (error) {
      if (error.name === 'TimeoutError') {
        await this.updateActionStatus(actionId, ActionStatus.ERROR_TIMEOUT, {
          message: 'ÌéòÏù¥ÏßÄ Î°úÎìú ÌÉÄÏûÑÏïÑÏõÉ'
        });
      }
      return false;
    }
  }

  /**
   * ÏöîÏÜå ÏÉÅÌÉú Ï∂îÏ†Å
   */
  async trackElement(actionId, page, selector) {
    try {
      // ÏöîÏÜå Ï∞æÍ∏∞
      const element = await page.waitForSelector(selector, { timeout: 5000 });
      if (!element) {
        await this.updateActionStatus(actionId, ActionStatus.ELEMENT_NOT_FOUND);
        return null;
      }
      
      await this.updateActionStatus(actionId, ActionStatus.ELEMENT_FOUND);
      
      // ÏöîÏÜå Í∞ÄÏãúÏÑ± ÌôïÏù∏
      const isVisible = await element.isVisible();
      if (isVisible) {
        await this.updateActionStatus(actionId, ActionStatus.ELEMENT_VISIBLE);
      }
      
      // ÏöîÏÜå ÌÅ¥Î¶≠ Í∞ÄÎä• ÌôïÏù∏
      const isEnabled = await element.isEnabled();
      if (isEnabled && isVisible) {
        await this.updateActionStatus(actionId, ActionStatus.ELEMENT_CLICKABLE);
      }
      
      return element;
    } catch (error) {
      await this.updateActionStatus(actionId, ActionStatus.ERROR_ELEMENT, {
        message: `ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${selector}`
      });
      return null;
    }
  }

  /**
   * Ïú†Ïó∞Ìïú ÏÉÅÌÉú Ï†ÑÌôò ÌóàÏö© Ïó¨Î∂Ä Ï≤¥ÌÅ¨
   */
  isFlexibleTransition(fromStatus, toStatus) {
    // Í∞úÎ∞ú/ÌÖåÏä§Ìä∏ Îã®Í≥ÑÏóêÏÑú ÌóàÏö©Ìï† Ï†ÑÌôòÎì§
    const flexibleTransitions = [
      // INITÏóêÏÑú Î™®Îì† ÏÉÅÌÉúÎ°úÏùò Ï†ÑÌôò ÌóàÏö© (ÌÖåÏä§Ìä∏Ïö©)
      { from: ActionStatus.INIT, to: ActionStatus.STARTED },
      { from: ActionStatus.INIT, to: ActionStatus.NAVIGATING },
      { from: ActionStatus.INIT, to: ActionStatus.DOM_READY },
      { from: ActionStatus.INIT, to: ActionStatus.LOADED },
      { from: ActionStatus.INIT, to: ActionStatus.ELEMENT_WAITING },
      { from: ActionStatus.INIT, to: ActionStatus.ELEMENT_FOUND },
      { from: ActionStatus.INIT, to: ActionStatus.ELEMENT_VISIBLE },
      { from: ActionStatus.INIT, to: ActionStatus.ELEMENT_CLICKABLE },
      { from: ActionStatus.INIT, to: ActionStatus.CLICKING },
      { from: ActionStatus.INIT, to: ActionStatus.CLICKED },
      { from: ActionStatus.INIT, to: ActionStatus.SUCCESS },
      { from: ActionStatus.INIT, to: ActionStatus.ERROR_TIMEOUT },
      { from: ActionStatus.INIT, to: ActionStatus.ERROR_UNKNOWN },
      
      // PENDINGÏóêÏÑú Î™®Îì† ÏÉÅÌÉúÎ°úÏùò Ï†ÑÌôò ÌóàÏö©
      { from: ActionStatus.PENDING, to: ActionStatus.STARTED },
      { from: ActionStatus.PENDING, to: ActionStatus.NAVIGATING },
      { from: ActionStatus.PENDING, to: ActionStatus.DOM_READY },
      { from: ActionStatus.PENDING, to: ActionStatus.LOADED },
      { from: ActionStatus.PENDING, to: ActionStatus.ELEMENT_WAITING },
      { from: ActionStatus.PENDING, to: ActionStatus.ELEMENT_FOUND },
      { from: ActionStatus.PENDING, to: ActionStatus.ELEMENT_VISIBLE },
      { from: ActionStatus.PENDING, to: ActionStatus.ELEMENT_CLICKABLE },
      { from: ActionStatus.PENDING, to: ActionStatus.CLICKING },
      { from: ActionStatus.PENDING, to: ActionStatus.CLICKED },
      { from: ActionStatus.PENDING, to: ActionStatus.SUCCESS },
      { from: ActionStatus.PENDING, to: ActionStatus.ERROR_TIMEOUT },
      { from: ActionStatus.PENDING, to: ActionStatus.ERROR_UNKNOWN },
      
      // Ïò§Î•ò ÏÉÅÌÉúÏóêÏÑú ÏÑ±Í≥µÏúºÎ°úÏùò Ï†ÑÌôò ÌóàÏö©
      { from: ActionStatus.ERROR_TIMEOUT, to: ActionStatus.SUCCESS },
      { from: ActionStatus.ERROR_ELEMENT, to: ActionStatus.SUCCESS }
    ];
    
    return flexibleTransitions.some(transition => 
      transition.from === fromStatus && transition.to === toStatus
    );
  }

  /**
   * ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ Ïï°ÏÖò ÏÉÅÌÉú
   */
  getActiveActions() {
    return Array.from(this.activeActions.values()).map(action => ({
      id: action.id,
      type: action.type,
      target: action.target,
      status: action.status,
      duration: Date.now() - action.startTime,
      processStep: action.processStep
    }));
  }

  /**
   * Ïï°ÏÖò ÌÜµÍ≥Ñ
   */
  getStatistics() {
    const stats = {
      totalActions: this.actionHistory.length,
      activeActions: this.activeActions.size,
      successCount: 0,
      partialSuccessCount: 0,
      errorCount: 0,
      averageDuration: 0,
      statusDistribution: {},
      errorTypes: {}
    };
    
    let totalDuration = 0;
    
    this.actionHistory.forEach(action => {
      if (action.status === ActionStatus.SUCCESS) stats.successCount++;
      else if (action.status === ActionStatus.PARTIAL_SUCCESS) stats.partialSuccessCount++;
      else if (isErrorStatus(action.status)) {
        stats.errorCount++;
        stats.errorTypes[action.status] = (stats.errorTypes[action.status] || 0) + 1;
      }
      
      totalDuration += action.totalDuration;
      
      // ÏÉÅÌÉú Î∂ÑÌè¨
      action.statusHistory.forEach(entry => {
        stats.statusDistribution[entry.status] = 
          (stats.statusDistribution[entry.status] || 0) + 1;
      });
    });
    
    if (stats.totalActions > 0) {
      stats.averageDuration = Math.round(totalDuration / stats.totalActions);
    }
    
    return stats;
  }
}

module.exports = ActionLoggerV2;